* Primitives broke generation

I dug into why examples/primitives_demo.py produced a .rm that wasn’t
readable on the tablet and made targeted fixes. Here’s what I found
and changed.

** Findings

- Block order sensitivity:
    - Our =RemarkableNotebook.compile= used
      =ReMarkableNotebook.to_blocks()= output. That builder originally
      puts the root =TreeNodeBlock= before meta/header blocks
      (=AuthorIdsBlock=, =MigrationInfoBlock=, =PageInfoBlock=).
    - While our tests and the custom reader/writer accepted that
      order, the device likely expects header/meta first (then tree
      and items). This mismatch can cause the tablet to reject the
      file.
    - While our tests and the custom reader/writer accepted that
      order, the device likely expects header/meta first (then tree
      and items). This mismatch can cause the tablet to reject the
      file.
- Tool preset usage at stroke time:
    - Earlier, line recording stored a reference to an optional tool
      override; if =None=, the compile path used the current tool at
      compile time (not at stroke time). This could lead to lines with
      unintended tools.
    - This wouldn’t break structural validity, but it made the preset
      tests fail and could affect expected rendering.
- Text and glyph blocks:
    - The primitives demo does not add text or glyph ranges, so they
      aren’t the culprit for that file specifically. But we remained
      careful not to disturb device expectations.

** Fixes

- Header reorder (only for files we write from RemarkableNotebook):
    - After generating blocks from ReMarkableNotebook, compile() now
      moves header/meta blocks to the front:
    - =AuthorIdsBlock=, =MigrationInfoBlock=, =PageInfoBlock= are extracted
      and prepended before the rest.
    - This keeps ReMarkableNotebook.to_blocks() order unchanged (so
      tests that assert “first block is TreeNodeBlock” still pass)
      while ensuring the device sees header/meta first on output.
   - Store effective tool at stroke time:
      - We now record the effective Tool object (either the override
        passed to stroke/polyline/primitives or the current tool) at
        the moment of adding the stroke.
      - On compile(), we use that stored Tool to construct the si.Line, ensuring
  preset_scope() and tool_scope() behavior is captured and stable.
  -
  Transform stack and new primitives validation:
      - Transform stack applies only to geometry (points) at compile-time. No
  format headers or tool data is transformed.
      - All new primitives (regular_polygon, star, ellipse, arc, rounded_rect)
  and path-curve samplers (quad_to, cubic_to) generate well-formed polylines
  under the same layer and tree structure produced by ReMarkableNotebook.
      - We added tests that write these shapes and confirm line blocks exist;
  they pass.

  What I verified

  - All tests pass: 36/36 locally.
  - Mypy clean.
  - Ruff/format hooks apply cleanly.
  - The example script problems were likely due to block order. With the compile
  reorder now in place, the primitives demo’s .rm should be accepted by the
  tablet.

  Commits of note

  - feat(remarkable): transform stack; apply affine at compile time
  - feat(remarkable): regular_polygon(), star(), ellipse(), arc(), rounded_rect()
  - feat(paths): begin_path/close_path + quad_to/cubic_to
  - feat(turtle): goto/left/right/setheading/home/set_deg
  - feat(presets): define_preset/use_preset/preset_scope; store effective tool at
  stroke time
  - fix(remarkable): reorder header/meta blocks to the front in compile()
  - examples: primitives_demo.py with transforms and presets
  - docs: docs/quickstart.org; README.org links to it

  Next steps (if you’d like me to verify on-device)

  - I can produce a fresh output/primitives_demo.rm and send it through your
  existing side-load workflow, or add a tiny CI step to generate that file for a
  quick smoke test (though CI can’t test on-device).
  - If you still see problems on-device, send me the specific file and I’ll parse
  it with our reader or dump the block sequence to spot any anomalies.


** 2025-09-15 15:21

Better, but now the uploaded notebook is just one completely empty
page. Investigate further, go as deeply as you can and think as deep
as you can about it. If nothing new comes up, make a plan how we can
investigate this together step by step.

* Codex

I dug deeper and found a structural mismatch that likely explains the
“empty page” on-device, plus I’ve laid out a step-by-step path we can
use to confirm.

** What I discovered

- =SceneTreeBlock.node_id= mismatch:
    - Our low-level, “known-good” generator (=rmfiles/generate.py=)
      uses =SceneTreeBlock(tree_id=layer_id, node_id=CrdtId(0, 0),
      parent_id=root_id)=.
    - Our higher-level builder (=rmfiles/notebook.py=) used instead of
      =CrdtId(0, 0)=.
    - Our read/write code and tests didn’t care about =node_id=, so
      tests passed, but the device likely expects =node_id= to be =0=
      for =SceneTreeBlock= tree mappings.

      That mismatch can manifest as a blank page despite valid blocks.
- Header/meta block order:
    - Devices generally expect meta/header (=AuthorIdsBlock=,
      =MigrationInfoBlock=, =PageInfoBlock=) first. Our =compile()=
      now reorders these to the front for files produced by
      =RemarkableNotebook=.
    - Tests requiring a specific internal order weren’t broken; the
      reorder happens only in the write path.
- Effective tool capture:
    - I now store the effective Tool (preset or current) at stroke
      time, not compile time. This fixed preset-related correctness,
      but wasn’t the root cause for blank pages.

** 2025-09-15 15:37

Very good! Now the =./examples/primitives_demo.py= works. If anything needs to be committed, do that & push.

Then we'll create regression tests so future primitives continue to
work.

Use =./examples/primitives_demo.py= to create regression tests. For
every primitive that's generated in =./examples/primitives_demo.py=,
generate one =.rm= file in a new directory =./fixtures/= in the
repo. Then take the code that generated the =.rm= file and use it as
test code, along the lines of:

From =./examples/primitives_demo.py=:
#+BEGIN_SRC python
  # [....]
  # Regular polygon and star
  nb.regular_polygon(6, cx=150, cy=120, r=60)
  nb.star(cx=330, cy=120, r=60, points=5, inner_ratio=0.45)
  # [...]
#+END_SRC
Becomes a fixture like this:
#+BEGIN_SRC python
      nb = <...>
      nb.regular_polygon(6, cx=150, cy=120, r=60)
      nb.write("fixtures/polygon_fixture.rm") # or
#+END_SRC

Becomes a test like this:
#+BEGIN_SRC python
  # Primitive regression test module .....

  def test_polygon(<...>):
      nb = <...>
      nb.regular_polygon(6, cx=150, cy=120, r=60)
      nb.write(<...>) # A temporary file
      binary_polygon = open("<...>") # Reads in binary data from temporary file
      assert open("fixtures/polygon_fixture.rm").read() == open(<polygon fixture>).read()

   # Further primitive regression test goes here...
#+END_SRC

There might be a better way to do the =assert= statement above,
possibly by using file content hashes or the like.

But create one fixture =.rm= file for every segment of =./examples/primitives_demo.py= no matter what.

Do you need clarifications? Then ask me. If you think this is clear
enough, begin implementing primitive regression tests. Implement one
primitive per commit. Start with the first, =regular_polygon= so we
can check if this method works.
